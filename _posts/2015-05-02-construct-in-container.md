---
layout: post
title:  construct in container
date: 2015-05-02
---

## 引子


这篇博文要说的事情是关于在容器实现相关的。话说前几日在实现一个容器类的时候，想着写的高大上一点，写个模板吧。这一写不要紧，发现遇到知识盲点了。

下面举个例子，譬如我有一个类

	class foo {
	}
	
那么容器`std::vector<foo>`在`push_back`一个对象的时候发生了什么？这个问题看似简单，其实不然啊。向里面新加入一个对象，那么在容器里面的对象跟传入的对象是什么关系呢？

## 揭秘

好在标准库的代码是都在的，不过吐槽一下，这标准库的代码是故意加密的么？这太不适合人类阅读了。

闲话少说。其实要完成一个容器类，其实是需要以下几个过程的。

1. 申请内存空间

2. 拷贝构造新申请的内容

3. 析构容器内部申请资源

4. 释放申请内存空间

`std::allocator`已经为上述操作进行了封装。其基本实现就是对`new`，`delete`等进行的封装。

当有新对象加入的时候，容器内部会进行申请内存，然后在新申请内存的地方进行placement new操作。当然，这需要对象支持拷贝构造方法。否则将无法编译通过。

而在析构的时候，容器需要显示的调用容器内部的生成对象的析构函数，然后再释放申请的内存。这样就能够保证整个容器的完整性。

## 结尾

有些事情天天在你眼前出现，但是却不知深意。“纸上得来终觉浅，绝知此事要躬行”。
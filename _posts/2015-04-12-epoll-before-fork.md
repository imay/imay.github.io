---
layout: post
title:  epoll before fork
date: 2015-04-12
---

Epoll这个强大的IO多路复用功能之前用过多次。今天这篇博客不是想介绍Epoll，而是想记录下另类的用法。

## 引子

在`Nginx`等系统中，fork出来的进程会对相同的Listen Socket使用不同的`epoll`来进行监听。这个可以正常运行，当一个connect请求过来时，任何一个进程监听的`Epoll`都可能会被唤醒。当然了，为了避免“惊群”效应，`Nginx`还是采取了对应的措施来避免。具体是什么方式，这里就不说了。

## 问题

有的时候自己就会问一些比较诡异的问题。上面是每个进程独立创建的epoll监听共享的socket可以正常工作没有问题。那么我有这样一个小问题，下面先来描述下这个问题：

	父进程：
	
	epoll_create();
	fork();
	// 子进程直接调用子进程函数
	epoll_wait();
	
	子进程：
	new_socket()
	epoll_add()
	
简单说下：

1. 父进程首先创建一个epollfd

2. fork出来的父进程监听epollfd

3. fork出来的子进程创建一个新的Listen_socket，然后在放入epollfd中

我的疑惑其实很简单，就是父进程调用epoll_wait会不会因为子进程的事件到来而返回？如果不返回，那么这个机制是怎么实现的？如果返回了，其实那个fd是不能被父进程访问的，如果父进程这个时候也有这个fd，那么很可能会造成异常情况。

## 实验

为此我写了一个简单的测试程序来进行了测试，具体的代码在[这里](https://gist.github.com/imay/dc46a4221676cf7cf7b4)。

**很遗憾的是：如果父子进程共享epollfd，那么epoll会将不属于epoll_wait调用者的事件返回给调用者。**

这对于使用epoll_fd的人来说是需要小心的一个地方，在多进程的环境中，避免使用多进程共享的epollfd。不过这个对于epoll的实现者来说可能是个福音:)

## 总结

其实这个问题是在我看到epoll实现的时候想到的。当然了，我没有在生产环境中使用过多进程epoll，所以没有相关经验。但是当我考虑到多进程复用epoll的时候会发现可能会存在上述的问题。

所以就写了个小程序测试下，测试证实了我的猜测……

总之，为了简单可依赖，就一句话：**多进程环境下，不要复用epollfd。**
	

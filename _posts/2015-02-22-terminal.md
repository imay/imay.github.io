---
layout: post
title:  terminal
date: 2015-02-22
---

## Terminal

对于我这种2000年才接触电脑的人来说，终端这种事情就太遥远了。就不说要像Linus一样从终端的控制程序写出了Linux，就连具体的工作机制也没有好好的了解过。迷迷糊糊的从Linux终端，SecureCRT，iTerm一路走来，就没想去了解下运作机制。一方面说明自己的好奇心比较弱；另一方面也说明了这些软件做的比较好，没遇到什么问题去迫使自己去了解。

正好赶上春节假期，一来自己闲来无事，二来放假前虽然解决了`vim`的颜色，但是对终端运作机制的一知半解还是困扰着自己。抱着闲着也是闲着的心态，系统的了解了下终端的工作原理，算是对自己内心疑惑的一个交代。

不过话说回来，在这样一个终端死绝的时代，我还在研究这玩意，活该自己没出息啊。不过也无所谓了，至少搞明白之后获得的喜悦感还是难以替代的。

诶呀，废话说的有点多了，还是赶紧进入正题吧。先见识下终端到底是什么样子的吧，由于我自己也没见过，就直接盗图了，特此感谢维基百科，原链[在此](http://en.wikipedia.org/wiki/VT100#mediaviewer/File:DEC_VT100_terminal.jpg)！

![vt100]({{ site.url }}/images/VT100_terminal.jpg)

上面是VT100的图片，其实对于上面的到底是一个电脑，还只是一个终端，我也说不太清楚。不过，无论是什么样子，最后的理论图其实是像下图一样。

![terminal logical]({{ site.url }}/images/terminal_logical.png)

好吧，我也不能说的再多了。为了好理解，就姑且把他理解成一个功能比较弱的显示器吧。

## terminfo

终端是一个人机交互设备，其实只是一个输出设备，需要与键盘这样的输入设备一起才能达到交互的作用。计算机，CPU可能会更确切一些，将要显示的字符或者指令字符串发送到终端设备中，终端设备就根据接收到的内容傻傻的执行，该显示的显示，该改变的改变。我估计（无根据猜测）最早的终端比较简单，只能够单向的输出，就是把接收到的字符全部打印到屏幕上。随着科技在发展，终端才有了一些其他功能，譬如[vt100](http://en.wikipedia.org/wiki/VT100)终端支持了光标的移动以及其他控制功能。

当时的世界百家争鸣哇，很多设备商都能生产自己的电脑。而设备提供商太多就会导致标准的不统一，譬如，你们家的光标移动的控制指令是"\E[abc"，而我们家的光标移动指令是"\E[bcd"。这就给上层应用程序带来了困扰，为了兼容不同的设备，就要更新代码。那像`VI/VIM`这种程序到底是设备提供商来更新呢？还是owner来更新呢？

不过，黑客们都很聪明啦，[terminfo](http://en.wikipedia.org/wiki/Terminfo)就提供了标准的编程接口，能够让用户不感知具体的设备而对终端进行操作。那么，具体怎么做的呢？

抽象terminal的功能，提炼出类似`cursor_left`，`cursor_up`这种功能字。[这里](http://pubs.opengroup.org/onlinepubs/7908799/xcurses/terminfo.html)有份汇总。这样用户程序通过标准的接口就能够获得`cursor_left`对应的终端指令字符串，而不去关心到底是哪一个设备了。上述的工作完成了编程接口的标准化，通过同样的API就能够操作不同厂商的终端了。

当然了，设备商也是需要做些工作的。terminfo使用文件夹+文件的方式来组织所有的终端信息。设备商们需要按照标准提供一份自己设备对应的描述信息，然后放到`${TERMINFO}`指定的位置中就可以了。这个文件内容是些什么呢？简单的理解就是一个映射关系，从标准的功能字映射到具体设备对应的字符集。这样应用程序就能够通过名字来获得对应的terminfo信息了。

对于屏幕操作的应用程序无一不是这么干的，譬如`VIM`啦，`TMUX`啦，统统如此。有兴趣的看看他们的代码就会看到具体怎么回事了。

## pty

科技在发展，时代在进步。过去那种只能够显示字符的终端已经成为了过去，取而代之的是功能更加强大的显示屏，而软件方面，视窗操作系统也带来了更加强大的交互功能，这导致硬件终端基本上在这个世界上就要消失了。但是，命令行这种高效的操作方式，在服务器端的世界中还是存活下来了。例如我每天都需要通过`SSH`登录到服务器上，然后进行各种命令操作，执行`vim`，所有的这些都是按照上面的terminal的方式进行的。只不过，现在叫做[PTY(Pseudo terminal)](http://en.wikipedia.org/wiki/Pseudoterminal)了。而充当我们终端设备的就是我敲入`SSH`这种命令的地方了，譬如`securecrt`，`iTerm`等。这些软件完成的功能就是将接收到的字符流在宿主操作系统中模拟对应的终端行为。

说到了这里也就比较容易理解为什么服务器端`TERM`系统变量设定的内容要跟终端软件中配置的终端类型一致了。否则对于字符理解就不一致啦，就达不到想要的效果了。

## ioctl

终端的内容谈完了，基本上就这么多了，但是其实还是遗漏了一些内容，这里补充下。在说之前，还是来个引子吧“为什么ssh登陆输入密码时看不到输入的内容？”。其实答案比较简单，通过`ioctl`或者`tcsetattr`设定当前进程的标准输入输出属性，设置为不回显即可。

为什么在这里谈这个事情呢？是因为我自己在探索终端工作机制的时候，这里的内容跟终端的内容有点混乱了。后来弄明白了后，其实很简单。通过`ioctl`或者`tcsetattr`设置的都是系统内核的行为，都是在内核发送给终端内容之前的行为。只要记住了这一点，就不会再有混乱了。

譬如用户输入的内容会回显，其实是内核偷偷的将用户输入的可见字符写入到了终端。这其实是两个层次的事情，心理清楚是怎么回事就可以了。

## 总结

想想自己知道有终端这回事已经6，7年了，这回才算是有些了解，还是挺惭愧的。不过还好，也算是有个交代了。

自己其实是写了一段试验代码的，不过写这篇博客的时候觉得太挫了，还是不拿出来丢人现眼了。等后面完善了再贴出来。

2月28日更新：
琢磨了半天写了一个简单的贪吃蛇，代码在[这里](https://gist.github.com/imay/d194e8ea66301d18ec07)。直接`gcc eat_snake.c -lncurses`编译。然后使用vim的方向键`h`，`j`，`k`，`l`进行控制蛇的方向。